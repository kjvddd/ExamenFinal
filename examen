Lucas Chernan.



1) Testing manual es la evaluacion y verificacion de un proceso de software. Utilizando herramientas unicamente manuales y no automatizadas. En este proceso se realizar prubas se realizan pruebas exploratorias del software.
Segun los casos de prueba que anteriormente fueron documentados. Es importante porque el tester humano interactua directamente con la interfaz de usario puede detectar mejor problemas de experiencia de usuario. 

2) Pasos a seguir para una diseñar un conjunto de pruebas manuales para una funcion serian: Reconocer los requisitos, Identificar Escenarios de uso (pruebas normales, pruebas limites), crear casos de prueba, Dejar en claro los resultados
esperados, Determinar la seguridad necesaria para la funcion( va depender de los datos que maneje), Documentacion de casos de prueba, Reportar cualquier defecto y continuar un seguimiento hasta su resolucion.

3) El testing funcional se enfoca mas en garantizar que el software cumpla con los requisitos funcionales. En otras palabras se pone a prueba si el software cumple con cada funcion especificada anteriormente. 
Y el testing no funcional se enfoca mas en la calidad del software, el rendimiento como tambien la comprobación de que el software sea optimo en terminos de usabilidad.

4) Caja negra en terminos de testing se basa en una vision del sistema desde el punto de vista de un usuario. Caja blanca seria una vision interna del sistema, y se usa para evaluar la calidad del codigo. 

5) Para una identificacion y reporte de un error los pasos a seguir son: Realizar pruebas manuales y automatizadas para poder localizar cualquier indicio de problema en el software, En caso de encontrar un error Registrar
que acciones desencadenaron el mismo . Compartirlo con el equipo de desarrollo y explicar de la mejor manera para poder llegar lo antes posible a la causa del error. 

6) Las pruebas de regresion son muy importantes para mantener la calidad del software mientras se va modificando, Permite una mayor velocidad en la respuesta del equipo de desarrollo para mantener la estabilidad del sistema.

9)En un proyecto con plazos muy ajustados lo mejor es darle una mayor planificacion mas exaustiva y darle prioridad a las situacines mas cruciales.

11) Las UAT (pruebas de aceptacion de usuario), se basan en verificar si el software cumple con las expectativas de los usuarios finales. en cambio las pruebas de sistema se enfocan en el rendimiento, y aspectos tecnicos. 

12) Las metodologias agiles tienden a se muy flexibles y de una evolucion constante dependiendo del proyecto. Enfoque principal, capacidad de respuesta a los cambios. 

13) El desarrollo en cascada se caracteriza por ser muy estructurado en cambio el desarrollo agil es mas flexible es mas adecuado para proyectos donde los requisitos pueden modificarse durante la etapa del desarollo. 
Desarrollo en cascada: Ventaja: Se realiza una documentacion completa en cada fase, que a largo plazo va a mejorar la comprension del proyecto
Desarollo Agil: Ventaja: Entregas frecuentes , y una mayor adaptabilidad a los cambios.

15) Para diseñar casos de prueba a una funcion se deberia comenzar con recopilacion de los requerimientos de la funcion, Identificar los escenarios de prueba, crear los datos de prueba
crear los casos de prueba, ejecutarlos, documentar los errores encontrados y tener un seguimiento del mismo para entender su comportamiento. 

16) Va depender del tipo de negocio y sus objetivos, determinar prioridades, el tiempo con el que cuento para realizar las pruebas. 
17) Los casos de prueba positivos evaluan si la funcion hace lo que supuestamente debeberia realizar correctamente, en tanto que los casos de prueba negativos se enfocan en cómo la funcion maneja entradas inesperadas o escenarios incorrectos. 
la proporcion de casos positivos y negativos va a depender de la etapa del proyecto, y la funcionalidad que se este probando. 

18) Los casos de prueba que deberian ejecutarse con prioridad son : Casos de prueba positivos para funcionalidades criticas, y casos de prueba negativos criticos. 
19) Casos de prueba funcionales: es verificar si el que el software cumpla con los requisitos funcionales. se basan en como el sistema debe responder y sus funcionalidades. 
    Casos de prueba NO funcionales: Se basan en la calidad y rendimiento del sistema, buscando una mejor optimizacion en cada una de sus funciones especificas.
21) En un bug report deberia tener como minimo: Un titulo, el nombre del tester, descripcion del bug, frecuencia, severidad y prioridad , ambientes, resultado deseado, resultado actual, 
camino de acciones para llegar al bug. 

25) En caso de encontrar un error ya documentado y todavia que no se resolvio me pondria en contacto con el equipo de desarrollo para ver si necesita alguna informacion necesaria. 
Si el problema viene persistiendo por mucho tiempo solicitaria la actualizacion de cuando va a estar resuelto el inconveniente. 

26) Frontend seria la interfaz visto del lado del cliente.
 Backend es la parte de una aplicacion web que los usuarios no ve.
Se encarga de la manipulación de datos y la comunicación con la base de datos.

27) SQL (Structured Query Language) Conviene utilizar este tipo de base de datos cuando la estructura de los datos es clara y no se modificara con frecuencia. 
NOSQL: seria mejor utilizar una base de datos no relacional cuando la estructura de los datos se cambie constantemente y para grandes volumenes de datos.
Hay ciertos casos que depende de los requisitos de la aplicacion se puede optar por una metodologia hibidra.

28) Una API es un conjunto de herramientas que permite a los desarrolladores de software acceder y utilizar las funciones o datos de una aplicacion especifica. Da lugar a la integracion efectiva de servicios 
y funcionalidades de terceros.

29) La programacion orientada a objetos ofrece una forma estructurada organizar el codigo, lo que permite un mejor entendimiento del codigo a terceros y el mantenimiento a largo plazo. 
Su principal concepto son las clases y objetos, se enfoca en la reutilizacion del codigo, la encapsulacion y la abstraccion. Permitiendo asi una mejor optimizacion.
30) Una clase es un molde que define la estructura y el comportamiento de los objetos. Un objeto es un especimen de una clase.
31) Una herencia se denomina a la palabra reservada Extends, que permite crear nuevas clases basadas en clases anteriores es una manera de optimizar y reutilizar el codigo 
Poliformismo: Muchos objetos pueden compartir un mismo metodo, pero cada uno puede tener una diferente implementacion y todos va a responder al mismo metodo.
El encapsulamiento sirve para ocultar informacion sensible o importante. Los modificadores de accesos que se pueden utilizar son private, public, protected. 



parte 2: 

1) El error en esta funcion es que intenta devolver un valor de tipo double como una cadena String. 
El codigo correcto seria:


public double calcularSueldo() {
    double sueldoContractor = tarifaContractor * getHorasTrabajadas();
    return sueldoContractor;
}

2) Los dos errores en el codigo son:

La palabra reservada class para declarar una clase no puede ser precedida por la palabra clave private.

El metodo tocar debe tener parentesis () despues del nombre del metodo para indicar que es un metodo.

El codigo correcto seria:

class Guitarra extends Instrumento {
    @Override
    public void tocar() {
        System.out.println("Tocar Guitarra");
    }
}

3) En el siguiente codigo se encuentra getter y setter de la funcion suma()

    public int getSuma() {
        return suma;
    }

    public void setSuma(int a, int b) {
        this.suma = sumar(a, b);
    }

    private int sumar(int a, int b) {
        return a + b;
    }

Parte 3: 

  //clase principal
1) public class Animales {
    private int cantidadPatas;
    private int edad;
    private String pelaje;

    //constructor
    public Animales(int cantidadPatas, int edad, String pelaje) {
        this.cantidadPatas = cantidadPatas;
        this.edad = edad;
        this.pelaje = pelaje;
    }

    //Getters y Setters 
    public int getCantidadPatas() {
        return cantidadPatas;
    }

    public void setCantidadPatas(int cantidadPatas) {
        this.cantidadPatas = cantidadPatas;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    public String getPelaje() {
        return pelaje;
    }

    public void setPelaje(String pelaje) {
        this.pelaje = pelaje;
    }
}

//Clase Perro herencia de Animales
public class Perro extends Animales {
    // Constructor que invoca al constructor de la clase base
    public Perro(int cantidadPatas, int edad, String pelaje) {
        super(cantidadPatas, edad, pelaje);
    }

    //Metodos de la clase Perro
    public void ladrar() {
        System.out.println("Guau");
    }

    public void jugar() {
        System.out.println("perroJugando");
    }
}

2) public class Main {
    public static void main(String[] args) {
        
        int[] numeros = {3, 5, 7, 13, 1};
  
        int maximo=numeros[0];

        for (int i = 1; i < numeros.length; i++) {
            if (numeros[i] > maximo) {
                maximo = numeros[i];
            }
        }
        System.out.println("El numero mas grande es: " + maximo);
    }
}


3) public class Main {
    public static void main(String[] args) {
        
        String palabraMinusculas = "domo";
        String palabraMayusculas = palabraMinusculas.toUpperCase();
        System.out.println("Palabra en mayúsculas: " + palabraMayusculas);
    }
}

