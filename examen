
1) Testing manual es la evaluacion y verificacion de un proceso de software. Utilizando herramientas unicamente manuales y no automatizadas. En este proceso se realizar prubas se realizan pruebas exploratorias del software.
Segun los casos de prueba que anteriormente fueron documentados. Es importante porque el tester humano interactua directamente con la interfaz de usario puede detectar mejor problemas de experiencia de usuario. 

2) Pasos a seguir para una diseñar un conjunto de pruebas manuales para una funcion serian: Reconocer los requisitos, Identificar Escenarios de uso (pruebas normales, pruebas limites), crear casos de prueba, Dejar en claro los resultados
esperados, Determinar la seguridad necesaria para la funcion( va depender de los datos que maneje), Documentacion de casos de prueba, Reportar cualquier defecto y continuar un seguimiento hasta su resolucion.

3) El testing funcional se enfoca mas en garantizar que el software cumpla con los requisitos funcionales. En otras palabras se pone a prueba si el software cumple con cada funcion especificada anteriormente. 
Y el testing no funcional se enfoca mas en la calidad del software, el rendimiento como tambien la comprobación de que el software sea optimo en terminos de usabilidad.

4) Caja negra en terminos de testing se basa en una vision del sistema desde el punto de vista de un usuario. Caja blanca seria una vision interna del sistema, y se usa para evaluar la calidad del codigo. 

5) Para una identificacion y reporte de un error los pasos a seguir son: Realizar pruebas manuales y automatizadas para poder localizar cualquier indicio de problema en el software, En caso de encontrar un error Registrar
que acciones desencadenaron el mismo . Compartirlo con el equipo de desarrollo y explicar de la mejor manera para poder llegar lo antes posible a la causa del error. 

6) Las pruebas de regresion son muy importantes para mantener la calidad del software mientras se va modificando, Permite una mayor velocidad en la respuesta del equipo de desarrollo para mantener la estabilidad del sistema.

8) 
9)En un proyecto con plazos muy ajustados lo mejor es darle una mayor planificacion mas exaustiva y darle prioridad a las situacines mas cruciales.

11) Las UAT (pruebas de aceptacion de usuario), se basan en verificar si el software cumple con las expectativas de los usuarios finales. en cambio las pruebas de sistema se enfocan en el rendimiento, y aspectos tecnicos. 

12) Las metodologias agiles tienden a se muy flexibles y de una evolucion constante dependiendo del proyecto. Enfoque principal, capacidad de respuesta a los cambios. 

13) El desarrollo en cascada se caracteriza por ser muy estructurado en cambio el desarrollo agil es mas flexible es mas adecuado para proyectos donde los requisitos pueden modificarse durante la etapa del desarollo. 
Desarrollo en cascada: Ventaja: Se realiza una documentacion completa en cada fase, que a largo plazo va a mejorar la comprension del proyecto
Desarollo Agil: Ventaja: Entregas frecuentes , y una mayor adaptabilidad a los cambios.

14)

15) 







parte 2: 

1) El error en esta funcion es que intenta devolver un valor de tipo double como una cadena String. 
El codigo correcto seria:


public double calcularSueldo() {
    double sueldoContractor = tarifaContractor * getHorasTrabajadas();
    return sueldoContractor;
}

2) Los dos errores en el codigo son:

La palabra reservada class para declarar una clase no puede ser precedida por la palabra clave private.

El metodo tocar debe tener parentesis () despues del nombre del metodo para indicar que es un metodo.

El codigo correcto seria:

class Guitarra extends Instrumento {
    @Override
    public void tocar() {
        System.out.println("Tocar Guitarra");
    }
}

3) En el siguiente codigo se encuentra getter y setter de la funcion suma()

    public int getSuma() {
        return suma;
    }

    public void setSuma(int a, int b) {
        this.suma = sumar(a, b);
    }

    private int sumar(int a, int b) {
        return a + b;
    }

Parte 3: 

  //clase principal
1) public class Animales {
    private int cantidadPatas;
    private int edad;
    private String pelaje;

    //constructor
    public Animales(int cantidadPatas, int edad, String pelaje) {
        this.cantidadPatas = cantidadPatas;
        this.edad = edad;
        this.pelaje = pelaje;
    }

    //Getters y Setters 
    public int getCantidadPatas() {
        return cantidadPatas;
    }

    public void setCantidadPatas(int cantidadPatas) {
        this.cantidadPatas = cantidadPatas;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    public String getPelaje() {
        return pelaje;
    }

    public void setPelaje(String pelaje) {
        this.pelaje = pelaje;
    }
}

//Clase Perro herencia de Animales
public class Perro extends Animales {
    // Constructor que invoca al constructor de la clase base
    public Perro(int cantidadPatas, int edad, String pelaje) {
        super(cantidadPatas, edad, pelaje);
    }

    //Metodos de la clase Perro
    public void ladrar() {
        System.out.println("Guau");
    }

    public void jugar() {
        System.out.println("perroJugando");
    }
}

2) public class Main {
    public static void main(String[] args) {
        
        int[] numeros = {3, 5, 7, 13, 1};
  
        int maximo=numeros[0];

        for (int i = 1; i < numeros.length; i++) {
            if (numeros[i] > maximo) {
                maximo = numeros[i];
            }
        }
        System.out.println("El numero mas grande es: " + maximo);
    }
}


3) public class Main {
    public static void main(String[] args) {
        
        String palabraMinusculas = "domo";
        String palabraMayusculas = palabraMinusculas.toUpperCase();
        System.out.println("Palabra en mayúsculas: " + palabraMayusculas);
    }
}

